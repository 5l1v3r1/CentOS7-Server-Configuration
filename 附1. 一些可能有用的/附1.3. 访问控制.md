## 附1.3. 访问控制

### 附1.3.1. ACL

这是配置ACL（访问控制列表）的示例。

CentOS默认安装ACL，如果没有，运行以下命令安装：

`yum -y install acl`

如果使用CentOS7上默认的[XFS文件系统](http://oss.sgi.com/projects/xfs/)，则不必设置预设置来使用ACL功能。如果使用CentOS6上默认的ext4文件系统，则需要设置预设置才能使用ACL功能。以下为设置预设置：

对于CentOS6，在初始操作系统安装时设置的设备上，ACL选项已经通过默认挂载选项启用：

`tune2fs -l /dev/VolGroup/lv_root | grep "Default mount options"` # 显示默认挂载选项

```
Default mount options:   user_xattr acl  # ACL选项已添加
```

对于在操作系统安装后添加的设备（如添加HDD等）的情况，需要手动启用ACL选项。一种方法是使用ACL选项挂载设备，另一种方法是在默认挂载选项中添加ACL选项：

使用ACL选项来挂载以启用ACL：

`mount -o acl /dev/sdb1 /mnt`

`mount | grep sdb1`

```
/dev/sdb1 on /mnt type ext4 (rw,acl)
```

或将ACL选项添加到默认挂载选项：

`tune2fs -o acl /dev/sdb1`

`tune2fs -l /dev/vdb1 | grep "Default mount options"`

```
Default mount options: acl
```

预设置完成后，关于如何设置ACL，以为文件`/home/test.txt`设置ACL为例：

`ll /home/test.txt`

```
-rwx------ 1 root root 10 Jul  3 16:17 /home/test.txt
```

`setfacl -m u:cent:r /home/test.txt` # 为用户“cent”设置`/home/test.txt`为r（读）

`ll /home/test.txt` # 设置ACL后，在属性添加了“+”

```
-rwxr-----+ 1 root root 10 Jul  3 16:17 /home/test.txt
```

`getfacl /home/test.txt` # 确认设置

```
getfacl: Removing leading '/' from absolute path names
# file: home/test.txt
# owner: root
# group: root
user::rwx
user:cent:r--
group::---
mask::r--
other::---
```

以用户“cent”尝试访问：

`cat /home/test.txt`

```
ACL test file  # 正常读取
```

以其他用户尝试访问：

`cat /home/test.txt`

```
cat: /home/test.txt: Permission denied  # 不能正常读取
```

递归设置ACL到目录：

`setfacl -R -m u:cent:r /home/testdir` # 为用户“cent”设置`/home/testdir`为r（读）

`ll /home/testdir`

```
total 4
-rwxr-----+ 1 root root 5 Jul  3 16:23 testfile
```

`getfacl -R /home/testdir`

```
getfacl: Removing leading '/' from absolute path names
# file: home/testdir
# owner: root
# group: root
user::rwx
user:cent:r--
group::---
mask::r--
other::---

# file: home/testdir/testfile
# owner: root
# group: root
user::rwx
user:cent:r--
group::---
mask::r--
other::---
```

按组设置ACL：

`setfacl -m g:security:rw /home/test.txt` # 为组“security”设置`/home/test.txt`为rw（读/写）

`getfacl /home/test.txt`

```
getfacl: Removing leading '/' from absolute path names
# file: home/test.txt
# owner: root
# group: root
user::rwx
user:cent:r--
group::---
group:security:rw-
mask::rw-
other::---
```

以组“security”中的用户“cent”尝试访问：

`echo "test write" >> /home/test.txt`

`cat /home/test.txt`

```
ACL test file
test write  # 正常写入
```

以不是组“security”中的用户尝试访问：

`echo "test write" >> /home/test.txt`

```
-bash: /home/test.txt: Permission denied  # 不能正常写入
```

移除ACL：

`setfacl -b /home/test.txt` # 从`/home/test.txt`移除ACL

`setfacl -x u:fedora /home/test.txt` # 仅为用户“fedora”在`/home/test.txt`移除ACL

为目录设置默认ACL。如果在设置了默认ACL的目录下创建文件/目录，默认访问属性是继承的。但要注意，如果使用`chmod`更改属性，则ACL将无效：

`setfacl -m u:cent:r-x /home/testdir`

为用户“cent”设置`/home/testdir`默认ACL为r-x（读/执行）：

`setfacl -d -m u:cent:r-x /home/testdir`

`getfacl /home/testdir`

```
getfacl: Removing leading '/' from absolute path names
# file: home/testdir
# owner: root
# group: root
user::rwx
user:cent:r-x
group::---
mask::r-x
other::---
default:user::rwx
default:user:cent:r-x
default:group::---
default:mask::r-x
default:other::---
```

`echo "ACL default setting" > /home/testdir/test.txt`

`ll /home/testdir/test.txt`

```
-rw-r-----+ 1 root root 20 Jan 31 22:32 /home/testdir/test.txt
```

以用户“cent”尝试访问：

`cat /home/testdir/test.txt`

```
ACL default setting  # 正常读取
```

移除默认ACL：

`setfacl -k /home/testdir`

`getfacl /home/testdir`

```
getfacl: Removing leading '/' from absolute path names
# file: home/testdir
# owner: root
# group: root
user::rwx
user:cent:r-x
group::---
mask::r-x
other::---
```

从配置文件设置ACL：

编辑`acl.txt`文件，创建ACL的配置文件（如果想在其他系统上设置ACL，可以使用`getfacl`命令导出）：

```
# file: /home/testdir
# owner: root
# group: root
user::rwx
user:cent:r-x
group::---
mask::r-x
other::---

# file: /home/test.txt
# owner: root
# group: root
user::rwx
user:cent:r--
group::---
mask::r--
other::---
```

`setfacl --restore=acl.txt`

`ll /home`

```
total 16
drwx------. 2 cent   cent   4096 Jan 31 12:14 cent
drwx------  2 fedora fedora 4096 Jan 31 12:14 fedora
drwxr-x---+ 2 root   root   4096 Jan 31 22:32 testdir
-rwxr-----+ 1 root   root     25 Jan 31 21:56 test.txt
```

### 附1.3.2. TCP Wrapper

这是[TCP Wrapper](https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Security_Guide/sec-Securing_Network_Access.html#sec-Securing_Services_With_TCP_Wrappers_and_xinetd)的TCP访问控制示例。

安装TCP Wrapper：

`yum -y install tcp_wrappers`

使用以下命令确认服务是否可以在TCP Wrapper控制下。如果包含`libwrap`的链接，表示可以：

`ldd /usr/sbin/sshd | grep wrap`

```
libwrap.so.0 => /lib64/libwrap.so.0 (0x00007f01b4e2a000)  # 这个服务可以在TCP Wrapper控制下，因为它包含'libwrap'
```

TCP Wrapper的访问控制配置在`/etc/hosts.allow`和`/etc/hosts.deny`中。下面示例演示设置允许从`10.0.0.0/24`访问sshd的配置：

编辑`/etc/hosts.deny`文件：

```
sshd: ALL
```

编辑`/etc/hosts.allow`文件：


```
sshd: 10.0.0.
```

对于允许从`host.example.domain`访问vsftpd的情况：

编辑`/etc/hosts.deny`文件：

```
vsftpd: ALL
```

编辑`/etc/hosts.allow`文件：


```
vsftpd: host.example.domain
```

下面这种情况，只允许从`example.domain`和`10.0.1.0/24`访问所有在TCP Wrapper控制下的服务：

编辑`/etc/hosts.deny`文件：

```
ALL: ALL
```

编辑`/etc/hosts.allow`文件：


```
ALL: .example.domain 10.0.1.
```

### 附1.3.3. SELinux

[SELinux](https://selinuxproject.org/page/Main_Page)（Security-Enhanced Linux安全增强式Linux）是美国国家安全局（NSA）对于强制访问控制的实现，是Linux历史上最杰出的新安全子系统。红帽上的[SELinux用户和管理员指南](https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/SELinux_Users_and_Administrators_Guide/)。

#### 附1.3.3.1. 操作模式

可以通过SELinux在CentOS上使用MAC（Mandatory Access Control强制访问控制）功能来获取各种资源。

如下确认SELinux的当前状态（默认模式为“Enforcing”）：

`getenforce` # 显示当前模式

```
Enforcing
```

* enforcing -> SELinux已启用（默认）
* permissive -> MAC未启用，但仅根据策略记录审计日志
* disabled -> SELinux已禁用

也可以使用下面命令显示（“Current mode”行）：

`sestatus`

```
SELinux status:                 enabled
SELinuxfs mount:                /sys/fs/selinux
SELinux root directory:         /etc/selinux
Loaded policy name:             targeted
Current mode:                   enforcing
Mode from config file:          enforcing
Policy MLS status:              enabled
Policy deny_unknown status:     allowed
Max kernel policy version:      28
```

可以通过`setenforce`命令在“permissive”和“enforcing”之间切换当前模式。但是如果系统重新启动，则模式将回到默认状态：

`getenforce`

```
Enforcing
```

`setenforce 0` # 切换到“Permissive”

`getenforce`

```
Permissive
```

`setenforce 1` # 切换到“Enforcing”

`getenforce`

```
Enforcing
```

如果要永久更改操作模式，更改配置文件中的值：

编辑`/etc/selinux/config`文件：

```
# This file controls the state of SELinux on the system.
# SELINUX= can take one of these three values:
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
# 更改为要设置的值
SELINUX=enforcing
# SELINUXTYPE= can take one of these two values:
#     targeted - Targeted processes are protected,
#     minimum - Modification of targeted policy. Only selected processes are protected.
#     mls - Multi Level Security protection.
SELINUXTYPE=targeted
```

`reboot` # 重启系统后生效

如果将操作模式从“Disabled”更改为“Enforcing/Permissive”，则需要使用SELinux上下文重新标记文件系统。因为当在“Disabled”模式下创建一些文件或目录时，它们没有使用SELinux上下文标记，需要对它们进行标记：

`touch /.autorelabel` # 如下设置重新标记，在下一次系统重新启动时完成

`reboot`

#### 附1.3.3.2. 策略类型

如果SELinux处于“Enforcing/Permissive”状态，可以选择策略类型。如果需要，可以根据自己的环境修改所选策略。

可以在`/etc/selinux/config`文件中设置策略类型。CentOS7默认策略是“targeted”策略。但是，如果要更改策略类型，需要安装策略文件。对于最小化安装的CentOS7，默认仅安装“targeted”策略。

**如果在不安装策略文件的情况下更改策略，系统将无法启动，请小心**。

`cat /etc/selinux/config`

```
# This file controls the state of SELinux on the system.
# SELINUX= can take one of these three values:
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
SELINUX=enforcing
# SELINUXTYPE= can take one of these two values:
#     targeted - Targeted processes are protected,
#     minimum - Modification of targeted policy. Only selected processes are protected.
#     mls - Multi Level Security protection.
# 默认为“targeted”
SELINUXTYPE=targeted
```

例如，改为“minimum”策略：

**首先安装策略文件**：

`yum -y install selinux-policy-minimum`

策略文件安装在`minimum`目录下：

`ll /etc/selinux`

```
total 16
-rw-r--r--. 1 root root  547 Mar 18 16:23 config
drwxr-xr-x. 6 root root 4096 Mar 18 17:26 minimum
-rw-r--r--. 1 root root 2321 Nov 20 16:04 semanage.conf
drwxr-xr-x. 6 root root 4096 Mar 18 16:24 targeted
```

编辑`/etc/selinux/config`文件：

```
# 更改“SELINUXTYPE”部门
# This file controls the state of SELinux on the system.
# SELINUX= can take one of these three values:
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
SELINUX=enforcing
# SELINUXTYPE= can take one of these two values:
#     targeted - Targeted processes are protected,
#     minimum - Modification of targeted policy. Only selected processes are protected.
#     mls - Multi Level Security protection.
SELINUXTYPE=minimum
```

`reboot` # 重启系统后生效

`sestatus`

```
SELinux status:                 enabled
SELinuxfs mount:                /sys/fs/selinux
SELinux root directory:         /etc/selinux
Loaded policy name:             minimum  # 已经变更
Current mode:                   enforcing
Mode from config file:          enforcing
Policy MLS status:              enabled
Policy deny_unknown status:     allowed
Max kernel policy version:      28
```

配置文件中的示例包括RPM包提供的三种策略：

| 策略 | 描述 |
| - | - |
| Targeted | 此策略将访问控制应用于通常的攻击目标进程（默认） |
| Minimum | 此策略包含的设置文件与“Targeted”策略相同，但是与“Targeted”策略相比，访问控制的目标进程少得多 |
| MLS | Multilevel Security Policy多级安全策略。它实现了Bell-LaPadula（BLP）模型，并可能应用更复杂的控件 |

#### 附1.3.3.3. SELinux上下文

对文件或目录的访问控制由称为SELinux Context（SELinux上下文）的附加信息控制。

SELinux上下文有以下语法：`[SELinux User]:[Role]:[Type]:[Level]`

* SELinux User：SELinux用户属性。每个Linux用户都通过SELinux策略映射到SELinux用户。
* Role：RBAC（Role Based Access Control基于角色的访问控制）属性。它定义了SELinux用户的角色，控制哪些定义的角色可以通过SELinux策略访问域（Domain）。
* Type：TE（Type Enforcement）属性。它定义了进程的域（Domain），并定义了文件类型。
* Level：MLS（Multi Level Security多级安全）和MCS（Multi Category Security多类别安全）属性。Level的语法：`[sensitivity]:[category]`
  * RHEL/CentOS默认的“targeted”策略强制MCS，此策略sensitivity只使用“s0” ，category支持“c0-c1023”。
  * MLS强制Bell-La Padula强制访问模型。如果想使用它，则需要在RHEL/CentOS上安装MLS策略软件包。但它不支持X Window系统，所以不能在桌面环境中使用。

要显示文件或进程的SELinux上下文，在命令中添加`Z`选项：

`ls -Z /root` # 文件/目录

```
                        User  :  Role  :    Type    : Level
                      --------:--------:------------:------
-rw-------. root root system_u:object_r:admin_home_t:s0     anaconda-ks.cfg
```

`ps axZ` # 进程

```
LABEL                             PID TTY      STAT   TIME COMMAND
system_u:system_r:init_t:s0         1 ?        Ss     0:01 /usr/lib/systemd/syst
system_u:system_r:kernel_t:s0       2 ?        S      0:00 [kthreadd]
system_u:system_r:kernel_t:s0       3 ?        S      0:00 [ksoftirqd/0]
.....
.....
system_u:system_r:postfix_master_t:s0 916 ?    Ss     0:00 /usr/libexec/postfix/
system_u:system_r:postfix_pickup_t:s0 917 ?    S      0:00 pickup -l -t unix -u
system_u:system_r:postfix_qmgr_t:s0 918 ?      S      0:00 qmgr -l -t unix -u
system_u:system_r:kernel_t:s0     941 ?        S<     0:00 [kworker/1:1H]
system_u:system_r:kernel_t:s0     966 ?        S<     0:00 [kworker/0:1H]
system_u:system_r:kernel_t:s0    1246 ?        S<     0:00 [kworker/0:2H]
```

`id -Z` # 自己的ID

```
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
```

`yum -y install policycoreutils-python` # 如果`semanage`命令不存在，则运行安装

每个Linux用户都通过SELinux策略映射到SELinux用户，可以显示如下的映射列表：

`semanage login -l`

```
Login Name           SELinux User         MLS/MCS Range        Service

__default__          unconfined_u         s0-s0:c0.c1023       *
root                 unconfined_u         s0-s0:c0.c1023       *
system_u             system_u             s0-s0:c0.c1023       *
```

对于上面的示例（RHEL/CentOS默认）：“root”映射到“unconfined_u”；“bin”或“daemon”等系统用户映射到“system_u”；其他普通用户映射到“__default__”一次，最后映射到“unconfined_u”。

“unconfined_u”用户被分配“unconfined_r”角色，由“unconfined_u”用户启动的进程以“unconfined_t”域运行。

“unconfined_t”域分配的进程不受SELinux控制。

`ps axZ | grep unconfined_t`

```
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 1435 ttyS0 Ss   0:00 -bash
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 1556 ttyS0 R+   0:00 ps axZ
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 1557 ttyS0 S+   0:00 grep --color=auto unconfined_t
```

#### 附1.3.3.4. 更改布尔值

在SELinux策略提供的RPM软件包如“targeted”，可以轻松地更改SELinux设置来切换布尔值。

下例是基于“targeted”策略环境。

可以如下使用布尔值：

`getsebool -a` # 显示列表和当前设置

```
abrt_anon_write --> off
abrt_handle_event --> off
abrt_upload_watch_anon_write --> on
.....
.....
zoneminder_anon_write --> off
zoneminder_run_sudo --> off
```

`semanage boolean -l` # 同时显示描述

```
SELinux boolean                State  Default Description

ftp_home_dir                   (off  ,  off)  Allow ftp to home dir
smartmon_3ware                 (off  ,  off)  Allow smartmon to 3ware
mpd_enable_homedirs            (off  ,  off)  Allow mpd to enable homedirs
.....
.....
cron_can_relabel               (off  ,  off)  Allow cron to can relabel
sftpd_anon_write               (off  ,  off)  Allow sftpd to anon write
```

例如，配置“samba_enable_home_dirs”布尔值。

“samba_enable_home_dirs”默认设置为“off”，表示启用了SELinux的访问控制。

如果像这样[配置了Samba完全访问共享文件夹](../8. 文件服务器/8.2. Samba.html#821-完全访问共享文件夹)，是不可能访问它，SELinux拒绝，因为正确的SELinux上下文没有分配给文件夹。

`semanage boolean -l | grep samba_enable_home_dirs` # 默认设置为“off”

```
samba_enable_home_dirs         (off  ,  off)  Allow samba to enable home dirs
```

设置完全访问的共享文件夹后，创建一些测试文件（SELinux上下文从`/home/share`目录继承）：

`ls -Z /home/share`

```
-rw-rw-r--. cent cent unconfined_u:object_r:home_root_t:s0 test2.txt
-rw-r--r--. root root unconfined_u:object_r:home_root_t:s0 test.txt
```

访问被拒绝如下，即使文件具有读取权限，父目录具有777权限：

![selinux-boolean1](../Contents/selinux-boolean1.png)

将“samba_enable_home_dirs”的布尔值更改为“on”，以便能够正常访问文件夹：

`setsebool -P samba_enable_home_dirs on`

`getsebool samba_enable_home_dirs`

```
samba_enable_home_dirs --> on  # 已变更
```

`ls -Z /home/share` # “samba_enable_home_dirs”为“off”时SELinux上下文被添加

```
-rw-rw-r--. cent cent unconfined_u:object_r:home_root_t:s0 test2.txt
-rw-r--r--. root root unconfined_u:object_r:home_root_t:s0 test.txt
```

`restorecon -R /home/share` # 恢复“samba_enable_home_dirs”的默认SELinux上下文

`ls -Z /home/share` # 显示SELinux上下文（更改为user_home_t）

```
-rw-rw-r--. cent cent unconfined_u:object_r:user_home_t:s0 test2.txt
-rw-r--r--. root root unconfined_u:object_r:user_home_t:s0 test.txt
```

所有配置完成后，可以如下所示访问文件夹：

![selinux-boolean2](../Contents/selinux-boolean2.png)

![selinux-boolean3](../Contents/selinux-boolean3.png)

#### 附1.3.3.5. 更改文件类型

可以修改访问控制设置以更改文件类型而不更改布尔值。

下例是基于“targeted”策略环境。

默认SELinux上下文的设置放在`[policy directory]/contexts/files`下面，如下所示：

`ll /etc/selinux/targeted/contexts/files`

```
total 2104
-rw-r--r--. 1 root root  368879 Mar 28 15:46 file_contexts
-rw-------. 1 root root 1336352 Mar 28 15:46 file_contexts.bin
-rw-r--r--. 1 root root   13169 Mar 28 15:46 file_contexts.homedirs
-rw-------. 1 root root   43960 Mar 28 15:46 file_contexts.homedirs.bin
-rw-r--r--. 1 root root       0 Feb 17 02:24 file_contexts.local
-rw-------. 1 root root      16 Mar 28 15:46 file_contexts.local.bin
-rw-r--r--. 1 root root  365908 Oct 21 11:19 file_contexts.pre
-rw-r--r--. 1 root root       0 Feb 17 02:24 file_contexts.subs
-rw-r--r--. 1 root root     422 Feb 17 02:24 file_contexts.subs_dist
-rw-r--r--. 1 root root     139 Feb 17 02:24 media
```

`head /etc/selinux/targeted/contexts/files/file_contexts`

```
/.*     system_u:object_r:default_t:s0
/[^/]+  --      system_u:object_r:etc_runtime_t:s0
/a?quota\.(user|group)  --      system_u:object_r:quota_db_t:s0
/nsr(/.*)?      system_u:object_r:var_t:s0
/sys(/.*)?      system_u:object_r:sysfs_t:s0
/xen(/.*)?      system_u:object_r:xen_image_t:s0
/mnt(/[^/]*)?   -l      system_u:object_r:mnt_t:s0
/mnt(/[^/]*)?   -d      system_u:object_r:mnt_t:s0
/bin/.* system_u:object_r:bin_t:s0
/dev/.* system_u:object_r:device_t:s0
```

例如，修改文件类型，以便在httpd上使用CGI：

在httpd上使用CGI的布尔值默认设置为“on”，因此可以使用默认SELinux设置在httpd设置上的默认目录`/var/www/cgi-bin/`下运行CGI：

`semanage boolean -l | grep httpd_enable_cgi`

```
httpd_enable_cgi               (on   ,   on)  Allow httpd to enable cgi
```

`grep "cgi" /etc/selinux/targeted/contexts/files/file_contexts | grep "httpd"`

```
/usr/.*\.cgi    --      system_u:object_r:httpd_sys_script_exec_t:s0
/opt/.*\.cgi    --      system_u:object_r:httpd_sys_script_exec_t:s0
/var/www/[^/]*/cgi-bin(/.*)?    system_u:object_r:httpd_sys_script_exec_t:s0
/var/www/html/[^/]*/cgi-bin(/.*)?       system_u:object_r:httpd_sys_script_exec_t:s0
/usr/lib/cgi-bin(/.*)?  system_u:object_r:httpd_sys_script_exec_t:s0
/var/www/cgi-bin(/.*)?  system_u:object_r:httpd_sys_script_exec_t:s0
/usr/lib/cgi-bin/(nph-)?cgiwrap(d)?     --      system_u:object_r:httpd_suexec_exec_t:s0
/var/log/cgiwrap\.log.* --      system_u:object_r:httpd_log_t:s0
```

`curl http://localhost/cgi-bin/index.py` # 创建测试脚本并访问它，可以访问了

```
CGI Test Page
```

但是，如果要在[另一个目录中使用CGI](../5. Web服务器/5.1. Apache httpd.html#515-使用python脚本)，即使httpd设置正确，访问也被拒绝：

`curl http://localhost/cgi-enabled/index.py`

```
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>500 Internal Server Error</title>
</head><body>
<h1>Internal Server Error</h1>
<p>The server encountered an internal error or
misconfiguration and was unable to complete
your request.</p>
.....
.....
```

`ls -Z /var/www/html/cgi-enabled` # “httpd_sys_content_t”被分配

```
-rwxr-xr-x. root root unconfined_u:object_r:httpd_sys_content_t:s0 index.py
```

在这种情况下，需要将文件类型更改为SELinux允许CGI的文件类型。

如下更改文件类型（注意：使用`chcon`命令做的更改会在使用`restorecon`命令或是重新标记文件系统后恢复）：

`chcon -t httpd_sys_script_exec_t /var/www/html/cgi-enabled/index.py`

`ls -Z /var/www/html/cgi-enabled`

```
-rwxr-xr-x. root root unconfined_u:object_r:httpd_sys_script_exec_t:s0 index.py
```

`curl http://localhost/cgi-enabled/index.py`

```
CGI Test Page  # 访问成功
```

如果想永久更改类型，按如下所示进行设置：

`semanage fcontext -a -t httpd_sys_script_exec_t /var/www/html/cgi-enabled/index.py`

`grep "cgi-enabled" /etc/selinux/targeted/contexts/files/file_contexts.local`

```
# 写为了默认上下文
/var/www/html/cgi-enabled/index.py    system_u:object_r:httpd_sys_script_exec_t:s0
```

`ls -Z /var/www/html/cgi-enabled`

```
-rwxr-xr-x. root root unconfined_u:object_r:httpd_sys_content_t:s0 index.py
```

`restorecon /var/www/html/cgi-enabled/index.py` # 用`restotecon`重置

`ls -Z /var/www/html/cgi-enabled`

```
# 已恢复
-rwxr-xr-x. root root unconfined_u:object_r:httpd_sys_script_exec_t:s0 index.py
```

`curl http://localhost/cgi-enabled/index.py`

```
CGI Test Page  # 访问成功
```

#### 附1.3.3.6. 更改端口类型






#### 附1.3.3.7. 搜索日志





#### 附1.3.3.8. 使用SETroubleShoot





#### 附1.3.3.9. 使用audit2allow






#### 附1.3.3.10. 使用matchpathcon






#### 附1.3.3.11. 使用sesearch






